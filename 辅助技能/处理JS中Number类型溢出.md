之前当我正在处理一个算法问题时，其中一个点使得我必须用到JS中的大数。我必须保证结果没有溢出（或者，如果溢出了，我必须知道）。在一个典型的人机对战中，你可以看到我处理数字溢出的方式和JavaScript语言自身所处理的不大一样。如果你想惊讶于JavaScript是如何处理数字类型溢出的，执行下面几行代码就好了。

```
var max = Number.MAX_VALUE;
var x = max + 10;
console.log(max, x, max===x);

var min = Number.MIN_VALUE;
var y = min / 10;
console.log(min, y, min===y);
```

你意识到实际的输出结果会和你所预料的不同，第一个`console.log`将会打印像这样的东西：

```
1.7976931348623157e+308
1.7976931348623157e+308
true
```
而第二个`console.log`却会输出像这样的东西：
```
5e-324
0
false
```

这其中到底发生了什么？在第一个情况中，当JavaScript发现一个极大的数溢出，该变量会被赋值为`Number.Max_Value`。而在第二种情况中，当JavaScript发现有一个极小的数溢出，该变量会被赋值为0。

### 处理JavaScript溢出
假定我们有如下等式：
```
c = a + b
```
如果该加法操作不会导致溢出，那以下等式也是成立的。
```
a == c - b and b == c- a
```

所以当进行两个数字的相加操作时，进行溢出判断最简单的方式就编写如下的函数：
```
function additionDoesOverflow(a, b) {
  var c = a + b;
 
  return a !== c-b || b !== c-a;
}
```
从现在开始，当我们处理有可能溢出的大数时，我们只需要在相加操作之前调用这个函数。

### 处理乘法时的数值溢出
你可以猜到，对于相乘我们也有相似的方法。
```
function multiplicationDoesOverflow(a, b) {
  var c = a * b;
 
  return a !== c/b || b !== c/a;
}
```

### 对于其他运算的溢出处理

我并不想让这篇文章各种可能运算的例子。你已经通过上面的两个例子获得了相应的办法，并且你可以将其应用到处理任何其他运算中。

### 大数是什么
有时，知道一个运算是否会溢出并不够。当你去大数的问题时，总会有JavaScript它本身解决不了的情况。在这种情况下，你可以依赖像mathjs这样的库。这个库支持数值类型、大数、复杂数值、分数、单位、字符串、数值和矩阵。当然，它会在性能上有所牺牲，包括内存和时间上。所以如果选择这个方案，务必谨慎些。

