(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{299:function(t,_,a){"use strict";a.r(_);var r=a(3),s=Object(r.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"一、web的诞生及网络基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、web的诞生及网络基础"}},[t._v("#")]),t._v(" 一、Web的诞生及网络基础")]),t._v(" "),a("h4",{attrs:{id:"_1-当今互联网的由来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-当今互联网的由来"}},[t._v("#")]),t._v(" 1.当今互联网的由来")]),t._v(" "),a("p",[t._v("蒂姆·伯纳斯·李在1989年的时候提出一种设想，借助多文档之间的相互关联形成的超文本(HyperText)，连成可相互参阅的WWW(World wide web，万维网)。")]),t._v(" "),a("p",[t._v("对于这个想法，李爵士(伊丽莎白二世给他发了爵士勋章)也提出了三个相应的解决方案：HTML，承载超文本内容；URL，标明文档所在的唯一地址；HTTP，文档在各个机器之间传递的协议。所以，李爵士可以说是FEer的祖师爷。")]),t._v(" "),a("h4",{attrs:{id:"_2-html和http的发展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-html和http的发展"}},[t._v("#")]),t._v(" 2.HTML和HTTP的发展")]),t._v(" "),a("p",[t._v("最早期的网页是非常简单的，只有简单的文字呈现和超链接跳转，能够显示图片都已经很了不起了。此外，最开始的时候，是没有CSS的，页面上的样式都由"),a("code",[t._v("<center> <big>")]),t._v("这样的标签来改变。直到1994年的时候，HTML 1.0已经经过了多次版本更迭，CSS才被提出。")]),t._v(" "),a("p",[t._v("HTTP的发展经历了0.9 -> 1.0 -> 1.1 的变动。尽管HTTP2.0早已到来，但大部分浏览器使用的仍是1.1版本。我之前的一次面试就被问到2.0中包含了那些新特性。详见"),a("a",{attrs:{href:"https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FHTTP%2F2",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"_3-互联网-万维网"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-互联网-万维网"}},[t._v("#")]),t._v(" 3.互联网&万维网")]),t._v(" "),a("p",[t._v("书中没有提及这一点，但我认为有不少人对这两个词没有清楚的概念。有一点很好区分的是，在上面说到李爵士的设想时，万维网是建立在相互连接的超文本上的。但除去查看超文本外，电脑还可以做更多的事，比如发邮件（SMTP）、文件传输（FTP）等，这些就不能称为万维网了，应该是互联网。在协议层面上来说，我们说万维网其实是在说HTTP，而互联网在应用层远不止HTTP这一个协议，还包括诸如上面提到SMTP、FTP等协议。万维网是包含在互联网中的一个功能，所以你可以笼统地认为，在浏览器的范围内都是万维网。")]),t._v(" "),a("h4",{attrs:{id:"_4-网络基础tcp-ip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-网络基础tcp-ip"}},[t._v("#")]),t._v(" 4.网络基础TCP/IP")]),t._v(" "),a("p",[t._v("之前说到的HTTP协议只是TCP/IP协议族中应用层中的一个协议。TCP/IP 协议存在的必要性，如同人类世界中双方的沟通需要使用都理解的符合规范的语言，计算机之间的沟通更是需要基于相同的方法。")]),t._v(" "),a("blockquote",[a("p",[t._v("不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们把这种规则称为协议(protocol)。")])]),t._v(" "),a("p",[t._v("TCP/IP协议族按层次分为应用层、传输层、网络层和数据链路层。应用层最靠近用户，越往后越底层。")]),t._v(" "),a("p",[a("strong",[t._v("应用层")]),t._v("向用户提供应用服务，包含FTP、DNS和HTTP等协议，开发者基于这些协议进行应用开发。")]),t._v(" "),a("p",[a("strong",[t._v("传输层")]),t._v("提供处于网络连接中的两台计算机之间的数据传输，包含TCP和UDP协议。")]),t._v(" "),a("p",[a("strong",[t._v("网络层")]),t._v("用来处理在网络上流动的数据包，规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。")]),t._v(" "),a("p",[a("strong",[t._v("链路层")]),t._v("用来处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围之内。")]),t._v(" "),a("p",[t._v("在进行网络通信时，会通过分层顺序与对方进行通信，发送端从应用层往下走，接收端则从链路层往上走。")]),t._v(" "),a("h4",{attrs:{id:"_5-与http关系密切的协议-ip、tcp和dns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-与http关系密切的协议-ip、tcp和dns"}},[t._v("#")]),t._v(" 5.与HTTP关系密切的协议：IP、TCP和DNS")]),t._v(" "),a("p",[t._v("前面说到IP协议的作用就是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件是IP地址和MAC地址。IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址配对。由于网络的变动，IP地址会变动，但MAC地址基本上不会更改。")]),t._v(" "),a("p",[t._v("通信双方的连接一般需要通过多台计算机和网络设备的中转，在进行中转的时候，会利用下一站中转设备的MAC地址来搜索下一个中转目标。不断获取连接路线的这个过程称为路由选择。")]),t._v(" "),a("p",[t._v("前面说到传输层包含TCP和UDP协议，TCP是能够确保可靠的协议。可靠在这里的含义是无论如何它都会确保数据最终到达另一方。说到可靠性保证，就无法不提三次握手。请求端首先发送一个带SYN(synchronize)标志的数据包给对方，接收端收到后，回传一个带有一个带有SYN和ACK(acknowledgement)标志的数据包以示传达确认信息（这一步表明接收端能正常接收请求端消息）。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束（表明请求端可以接收到接收端回传的消息）。")]),t._v(" "),a("h4",{attrs:{id:"_6-负责域名解析的dns服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-负责域名解析的dns服务"}},[t._v("#")]),t._v(" 6.负责域名解析的DNS服务")]),t._v(" "),a("p",[t._v("真正标识一个计算机位置的是IP地址，但对于每个网站我们使用的是域名，所以在每个请求发送前，需要到DNS服务器查询该域名对应的IP地址。域名系统在应用层上使用的就是UDP(user data  protocol用户数据报协议)。UDP相较于TCP较为明显的不同之处在于，UDP不保证消息的可靠传递，但是速度比TCP快。")]),t._v(" "),a("h4",{attrs:{id:"_7-各种协议与http协议的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-各种协议与http协议的关系"}},[t._v("#")]),t._v(" 7.各种协议与HTTP协议的关系")]),t._v(" "),a("p",[t._v("其实这就是著名面试题“在浏览器输入域名按下回车后发生的事”的答案。在通过域名系统获得目标网站IP地址后，HTTP协议会生成针对目标Web服务器的HTTP请求报文；到达传输层后，TCP协议为了方便通信，将HTTP请求分割成有序的报文段；在网络中，IP协议搜索对方的地址，一边中转一边传送；到达目标服务器后，TCP协议将接受到的被分割的报文段重组成报文，HTTP协议对请求的内容进行响应，回传请求内容。当然，若要说答案，这只能说是基于各协议层面上非常粗略的一份。在这些之外，还涉及到内容缓存、过期时间、render tree构建和渲染等其他知识。")]),t._v(" "),a("h4",{attrs:{id:"_8-uri和url"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-uri和url"}},[t._v("#")]),t._v(" 8.URI和URL")]),t._v(" "),a("p",[t._v("URI是统一资源标识符，URL是统一资源定位符。URI是由某个协议方案表示的资源定位标识符。URL是URI的子集。")]),t._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("http")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("www"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("baidu"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v("#chapter1\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("上面是我瞎写的一个URL，其中"),a("code",[t._v("http")]),t._v("是协议方案名；"),a("code",[t._v("www.baidu.com:80")]),t._v("是服务器地址，因为80是默认端口，所以一般不写，但开发环境中我们就会见到需要填写端口的情况；"),a("code",[t._v("dir/index.html")]),t._v("是带层次的文件路径；"),a("code",[t._v("?id=9")]),t._v("是查询字符串；"),a("code",[t._v("#chapter1")]),t._v("是片断标识符，即一个页面中的锚点，有它打开后会直接到页面中锚点所在位置。")]),t._v(" "),a("p",[t._v("书中没有说到一个点是同源策略，同源策略是指协议相同，域名相同，端口相同。同源策略的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。")]),t._v(" "),a("h3",{attrs:{id:"二、简单的http协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、简单的http协议"}},[t._v("#")]),t._v(" 二、简单的HTTP协议")]),t._v(" "),a("h4",{attrs:{id:"_1-http协议用于客户端和服务端之间的通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-http协议用于客户端和服务端之间的通信"}},[t._v("#")]),t._v(" 1.HTTP协议用于客户端和服务端之间的通信")]),t._v(" "),a("p",[t._v("在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端时客户端，另一端则是服务端。请求文本或者图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。")]),t._v(" "),a("h4",{attrs:{id:"_2-通过请求和响应的交换达成通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-通过请求和响应的交换达成通信"}},[t._v("#")]),t._v(" 2.通过请求和响应的交换达成通信")]),t._v(" "),a("p",[t._v("请求必定由客户端发出，而服务器端回复响应。也就是说，一条通信线路的建立肯定是从客户端开始建立的，服务器端在没有接受到请求之前不会发送响应。可以通俗地理解为，客户端永远都只能是向服务器端告白的那个，能不能得到答复还得看服务器端。")]),t._v(" "),a("p",[t._v("请求报文是由"),a("strong",[t._v("请求方法")]),t._v("、"),a("strong",[t._v("请求URL")]),t._v("、"),a("strong",[t._v("协议版本")]),t._v("、可选的"),a("strong",[t._v("首部字段")]),t._v("和"),a("strong",[t._v("内容实体")]),t._v("构成的。")]),t._v(" "),a("p",[t._v("首部字段header fields 消息体entity body")]),t._v(" "),a("h4",{attrs:{id:"_3-http是不保存状态的协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-http是不保存状态的协议"}},[t._v("#")]),t._v(" 3.HTTP是不保存状态的协议")]),t._v(" "),a("p",[t._v("HTTP协议自身不对请求和响应之间的通信状态进行保存。鱼有七秒钟的记忆，HTTP只有“两秒”。协议本身并不保留之前一起的请求或响应报文的信息。")]),t._v(" "),a("h4",{attrs:{id:"_4-请求uri定位资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-请求uri定位资源"}},[t._v("#")]),t._v(" 4.请求URI定位资源")]),t._v(" "),a("p",[t._v("HTTP协议使用URI定位互联网上的资源，正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。")]),t._v(" "),a("p",[t._v("URI和URL的区别想必各位或多或少都清楚，此处不展开。")]),t._v(" "),a("h4",{attrs:{id:"_5-告知服务器意图的http方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-告知服务器意图的http方法"}},[t._v("#")]),t._v(" 5.告知服务器意图的HTTP方法")]),t._v(" "),a("p",[a("strong",[t._v("GET")]),t._v("用来请求访问已被URI识别的资源。一般请求的内容是文档图片等，还有后端接口 CGI。")]),t._v(" "),a("p",[a("strong",[t._v("POT")]),t._v("传输实体的主体，entity部分？")]),t._v(" "),a("p",[a("strong",[t._v("PUT")]),t._v("传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。")]),t._v(" "),a("p",[a("strong",[t._v("HEAD")]),t._v("获得报文首部，和GET方法一样，只是不返回报文主体部分。")]),t._v(" "),a("p",[a("strong",[t._v("DELETE")]),t._v("删除文件，与PUT方法相反，用于删除指定资源")]),t._v(" "),a("p",[a("strong",[t._v("OPTIONS")]),t._v("询问支持的方法，用来查询针对请求URI指定的资源支持的方法。")]),t._v(" "),a("p",[a("strong",[t._v("TRACE")]),t._v("让Web服务器将之前的请求通信返回给客户端，和命令行trace的区别")]),t._v(" "),a("p",[a("strong",[t._v("CONNECT")]),t._v("要求用隧道协议连接代理，使用SSL&TLS协议加密通信内容再经网络隧道传输。")]),t._v(" "),a("h4",{attrs:{id:"_6-使用方法下达命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-使用方法下达命令"}},[t._v("#")]),t._v(" 6. 使用方法下达命令")]),t._v(" "),a("p",[t._v("方法的作用在于，可以指定请求的资源按期望产生某种行为。")]),t._v(" "),a("p",[t._v("其实就是上面说到的那些HTTP方法。")]),t._v(" "),a("h4",{attrs:{id:"_7-持久连接节省通信量。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-持久连接节省通信量。"}},[t._v("#")]),t._v(" 7.持久连接节省通信量。")]),t._v(" "),a("p",[t._v("在HTTP的初始版本中，每进行依次HTTP通信就要断开一次TCP连接。")]),t._v(" "),a("h6",{attrs:{id:"持久连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#持久连接"}},[t._v("#")]),t._v(" 持久连接")]),t._v(" "),a("p",[t._v("持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。\n持久连接的好处在于减少了TCP连接的重复的建立和断开所造成的额外开销，减轻了服务器端的负载。，此外，这还减少了HTTP请求和响应的等待时间。")]),t._v(" "),a("h6",{attrs:{id:"管线化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管线化"}},[t._v("#")]),t._v(" 管线化")]),t._v(" "),a("p",[t._v("持久连接使得多数请求以管线化方式发送成为可能。管线化技术使得网页不用等待响应亦可直接发送下一个请求。")]),t._v(" "),a("p",[t._v("那是不是管线化是建立在持久连接的基础上的，浏览器端和服务器端只能存在一个TCP连接吗。")])])}),[],!1,null,null,null);_.default=s.exports}}]);