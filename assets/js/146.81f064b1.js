(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{348:function(v,t,l){"use strict";l.r(t);var _=l(3),i=Object(_.a)({},(function(){var v=this,t=v.$createElement,l=v._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"from-拉勾"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#from-拉勾"}},[v._v("#")]),v._v(" from 拉勾")]),v._v(" "),l("p",[v._v("为什么需要虚拟DOM，直接创建DOM的成本太大了。")]),v._v(" "),l("p",[v._v("虚拟DOM 就是一个JavaScript对象。\n为什么使用virtual DOM\n手动操作DOM比较麻烦，还需要考虑浏览器兼容性问题，虽然有jQuery等库简化DOMæ作，但是随着项目的复杂DOM操作复杂提升")]),v._v(" "),l("ul",[l("li",[v._v("为了简化DOM的复杂操作于是出现了各种MVVM框架，MVVM框架解决了视图和状态的同步问题")]),v._v(" "),l("li",[v._v("为了简化视图的操作我们可以使模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是VirtualDOM出现了")]),v._v(" "),l("li",[v._v("VirtualDOM的好处是当状态改变时不需要立即更新DOM，只需要创建一个虚拟树来描述DOM,VirtualDOM内部将弄清楚如何有效（diff）的的更新DOM")])]),v._v(" "),l("p",[v._v("参考github上virtual-dom的描述")]),v._v(" "),l("ul",[l("li",[v._v("虚拟DOM可以维护程序的状态，跟踪上一次的状态")]),v._v(" "),l("li",[v._v("通过比较前后两次状态的差异更新真实DOM")])]),v._v(" "),l("p",[v._v("虚拟DOM的作用")]),v._v(" "),l("ul",[l("li",[v._v("维护视图和状态的关系")]),v._v(" "),l("li",[v._v("复杂视图情况下提升渲染性能")]),v._v(" "),l("li",[v._v("除了渲染DOM以外，还可以实现SSR(next.js nuxt.js)、原生应用（Weex / React Native）、小程序（mpvue/uni-app）等")])]),v._v(" "),l("p",[v._v("virtual dom库")]),v._v(" "),l("ul",[l("li",[v._v("snabbdom")]),v._v(" "),l("li",[v._v("virtual-dom")])])])}),[],!1,null,null,null);t.default=i.exports}}]);