(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{380:function(v,_,l){"use strict";l.r(_);var i=l(3),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"虚拟dom"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[v._v("#")]),v._v(" 虚拟dom")]),v._v(" "),l("p",[v._v("创建真实dom内存开销大，性能成本高；virtual dom 够简单，属性少，以至于成本小，本质上就是一个js对象，")]),v._v(" "),l("ul",[l("li",[v._v("为什么使用virtual dom")]),v._v(" "),l("li",[v._v("手动操作dom 麻烦，还需考虑浏览器兼容性问题，即便有库简化dom操作，但随着项目复杂，dom操作也随之更复杂")]),v._v(" "),l("li",[v._v("为了简化dom的复杂操作，出现了各种mvvm矿建，这些框架解决了视图和状态同步的问题，")]),v._v(" "),l("li",[v._v("为了简化视图操作，可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是virtual dom出现了，这句和上句没看懂。")]),v._v(" "),l("li",[v._v("virtual dom 的好处是当状态改变的时候不需要立即更新dom，只需要创建一个虚拟树来描述dom，virtual dom 内部将弄清楚如何有效更新dom")]),v._v(" "),l("li",[v._v("简单来说，把开发人员手动更新dom 这件事交给了virtual dom，virtual dom 能做更棒")]),v._v(" "),l("li",[v._v("棒在，可以维护程序的状态，跟踪上一次状态；还可以通过比较前后两次状态的差异更新真是dom")])]),v._v(" "),l("p",[v._v("虚拟dom 能够实现")]),v._v(" "),l("ul",[l("li",[v._v("真实dom")]),v._v(" "),l("li",[v._v("ssr")]),v._v(" "),l("li",[v._v("原生应用")]),v._v(" "),l("li",[v._v("小程序")])]),v._v(" "),l("p",[v._v("snabbdom")]),v._v(" "),l("ul",[l("li",[v._v("vue 2.x 改造此而来")]),v._v(" "),l("li",[v._v("200 sloc")]),v._v(" "),l("li",[v._v("通过模块可拓展")]),v._v(" "),l("li",[v._v("源码使用ts开发")]),v._v(" "),l("li",[v._v("最快的virtual dom之一\nvirtual-dom")])]),v._v(" "),l("p",[v._v("源码解析")]),v._v(" "),l("h3",{attrs:{id:"如何学习源码"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#如何学习源码"}},[v._v("#")]),v._v(" 如何学习源码")]),v._v(" "),l("ul",[l("li",[v._v("先宏观了解")]),v._v(" "),l("li",[v._v("带着目标看源码")]),v._v(" "),l("li",[v._v("看源码的过程要不求甚解")]),v._v(" "),l("li",[v._v("调试")]),v._v(" "),l("li",[v._v("参考资料")])]),v._v(" "),l("h3",{attrs:{id:"snabbdom-的-核心流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#snabbdom-的-核心流程"}},[v._v("#")]),v._v(" snabbdom 的 核心流程")]),v._v(" "),l("ul",[l("li",[v._v("使用h()函数创建JavaScript对象（vnode）描述真实dom")]),v._v(" "),l("li",[v._v("inits()设置模块，创建patch()")]),v._v(" "),l("li",[v._v("patch()比较新旧两个vnode")]),v._v(" "),l("li",[v._v("把变化的内容更新到真实dom树上")])]),v._v(" "),l("p",[v._v("snabbdom的h函数用来创建vnode")]),v._v(" "),l("p",[v._v("patch函数")]),v._v(" "),l("ul",[l("li",[v._v("patch(oldVnode, newVnode)")]),v._v(" "),l("li",[v._v("打补丁，把新节点中变化的内容渲染到真实dom，最后返回新节点作为下一次处理的旧节点")]),v._v(" "),l("li",[v._v("对比新旧vnode是否相同节点（节点的key和sel相同）")]),v._v(" "),l("li",[v._v("如果不是相同节点，删除之前的内容，重新渲染")]),v._v(" "),l("li",[v._v("如果是相同节点，再判断新的vnode是否有text，如果有并且和oldvnode的text不同，直接更新文本内容")]),v._v(" "),l("li",[v._v("如果新的vnode有children，判断子节点是否有变化，判断子节点的过程使用的就是diff算法")]),v._v(" "),l("li",[v._v("diff过程只进行同层级比较")])]),v._v(" "),l("p",[v._v("init 函数")])])}),[],!1,null,null,null);_.default=t.exports}}]);