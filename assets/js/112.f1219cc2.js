(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{312:function(n,e,t){"use strict";t.r(e);var a=t(3),o=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("数组的解构赋值\nES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。\n解构不成功，变量的值都会等于undefined。")]),n._v(" "),t("p",[n._v("如果等号的右边不是数组，或者严格的说，不是可遍历解构，那么将会报错")]),n._v(" "),t("p",[n._v("对于Set结构，也可以使用数组的解构赋值，事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值，")]),n._v(" "),t("p",[n._v("解构赋值允许指定默认值,默认值生效的条件是，对象的属性值严格等于undefined\nlet [foo = true]=true\nfoo//true")]),n._v(" "),t("p",[n._v("let [x,y='b']=['a']; //x='a' y='b'\nlet [x,y='b']=['a',undefined] //x='a',y='b'")]),n._v(" "),t("p",[n._v("对象的结构赋值\nlet {foo,bar}={foo:'aaa',bar:'bbb'};\nfoo //'aaa'\nbar //'bbb'")]),n._v(" "),t("p",[n._v("let {foo:baz}={foo:'aaa',bar:'bbb'};\nbaz // 'aaa'")]),n._v(" "),t("p",[n._v("对象的解构与数组的有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；\n而由于对象的属性没有次序，变量必须与属性同名。")]),n._v(" "),t("p",[n._v("字符串的解构赋值\n使用数组的解构赋值的形式，如果等号右边不是一个数组，\n会将其转换成类数组对象 有length属性")]),n._v(" "),t("p",[n._v("数值和布尔值的解构赋值\n如果等号右边是数值和布尔值，则会专为对象\nlet {toString: s} = 123;\ns === Number.prototype.toString\n去等式右边找一个叫toString的东西  把他交给s")]),n._v(" "),t("p",[n._v("解构赋值的规则是 只要等号右边的值不是对象或数组，就先将其转为对象。\n由于undefined和null 无法转为对象，所以对他们进行解构赋值，都会报错。")]),n._v(" "),t("p",[n._v("函数的参数也可以使用解构赋值")]),n._v(" "),t("p",[n._v("不能使用圆括号的情况\n变量声明语句\n函数参数\n赋值语句的模式")]),n._v(" "),t("p",[n._v("解构赋值的用途\n交换变量的值\n从函数返回多个值\n函数参数的定义\n提取JSON数据\n函数参数的默认值\n遍历Map解构")]),n._v(" "),t("p",[n._v("function getB1({name=\"zhufeng\",age=100}={}){\nconsole.log(name,age);\n}\nfunction getB2({name,age}={name:'zhufeng',age:100}){\nconsole.log(name,age);\n}\n当传入空对象时，getB2打印出的name和age 都是undefined")])])}),[],!1,null,null,null);e.default=o.exports}}]);