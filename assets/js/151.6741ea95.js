(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{352:function(s,e,n){"use strict";n.r(e);var t=n(3),r=Object(t.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h3",{attrs:{id:"题目内容"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目内容"}},[s._v("#")]),s._v(" 题目内容")]),s._v(" "),n("p",[s._v('编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。')]),s._v(" "),n("h3",{attrs:{id:"解法一-暴力破解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解法一-暴力破解"}},[s._v("#")]),s._v(" 解法一，暴力破解")]),s._v(" "),n("p",[s._v("老实说，对于这个暴力法一开始还想了一会，没想出来的是纠结于如何比较两个字符串中每一个字符。后面才想起，字符串也是有length的，也可以通过下标来获取其中的每一个字符。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var longestCommonPrefix = function(strs) {\n    var re = '';\n    if (!strs.length) return re;\n    for (var j=0;j<strs[0].length;j++){//第j位\n        for (var i=1;i<strs.length;i++){//第i个\n            if (strs[i][j]!=strs[0][j]) return re\n        }\n        re += strs[0][j];\n    }\n    return re;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br")])]),n("p",[s._v("暴力破解法的思路就是，将下标为1及其后面的字符串的每一个字符和下标为0的字符想比较，如果此次循环的比较都相等，那公共前缀就加上此次比较的字符。这样讲很抽象，下面以一个数字为例。\n"),n("code",[s._v('["flower","flow","flight"]')])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("外层循环第一次")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("内存循环第一次\n比较"),n("code",[s._v("f")]),s._v("low 和 "),n("code",[s._v("f")]),s._v("lower，相等则继续循环")])]),s._v(" "),n("li",[n("p",[s._v("内层循环第二次\n比较"),n("code",[s._v("f")]),s._v("light 和 "),n("code",[s._v("f")]),s._v("lower, 相等则完成第一次外层循环的所有内层循环")]),s._v(" "),n("p",[s._v("re 为 "),n("code",[s._v("f")])])])])]),s._v(" "),n("li",[n("p",[s._v("外层循环第二次")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("内存循环第一次\n比较f"),n("code",[s._v("l")]),s._v("ow 和 f"),n("code",[s._v("l")]),s._v("ower，相等则继续循环")])]),s._v(" "),n("li",[n("p",[s._v("内层循环第二次\n比较f"),n("code",[s._v("l")]),s._v("ight 和 f"),n("code",[s._v("l")]),s._v("ower, 相等则完成第一次外层循环的所有内层循环")]),s._v(" "),n("p",[s._v("re 为"),n("code",[s._v("fl")])])])])]),s._v(" "),n("li",[n("p",[s._v("外层循环第三次")]),s._v(" "),n("ul",[n("li",[s._v("内存循环第一次\n比较fl"),n("code",[s._v("o")]),s._v("w 和 fl"),n("code",[s._v("o")]),s._v("wer，相等则继续循环")]),s._v(" "),n("li",[s._v("内层循环第二次\n比较fl"),n("code",[s._v("i")]),s._v("ght 和 fl"),n("code",[s._v("o")]),s._v("wer, 不相等则退出所有循环，答案为前一次的re")])])])]),s._v(" "),n("h3",{attrs:{id:"解法二-while配合slice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解法二-while配合slice"}},[s._v("#")]),s._v(" 解法二，while配合slice")]),s._v(" "),n("p",[s._v("这个解法是在题解区名为"),n("code",[s._v("JavaScript超快思路")]),s._v("作者写的，测试后其时间复杂度确实不高。名副其实。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("var longestCommonPrefix = function(strs) {\n    let t = strs[0] || '';\n    let i = 1;\n    while(t && i < strs.length) {\n        if(strs[i].indexOf(t) != 0) {\n            t = t.slice(0, t.length - 1);\n        } else {\n            i++;\n        }\n    }\n    return t;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])]),n("p",[s._v("这个解法的逻辑是，假定数组中的第一个字符串为最终答案。然后进入while循环，判断第二个字符串中是否包含第一个字符串，在上面的举例中，"),n("code",[s._v("flow")]),s._v("显然没有包含"),n("code",[s._v("flower")]),s._v("。此时就要削第一个字符串，削到第二个字符串包含他为止。后面如法炮制。")]),s._v(" "),n("p",[s._v("这个思路很赞的一点是把题目要求取最长公共前缀想的很透彻，既然是公共前缀就一定能满足包含于其它字符串的条件。又因为是前缀，所以当不满足条件是就从后往前削。")]),s._v(" "),n("p",[s._v("此外，此处假定数组第一项为答案，只是为了方便循环。假定第二项也没有问题，因为都会被削至满足条件。")])])}),[],!1,null,null,null);e.default=r.exports}}]);