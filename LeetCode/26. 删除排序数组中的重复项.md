### 题目内容
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

又是原地算法，吃一堑长一智...

### 解法一，Set去重
看到去重，脑子里首先想到的是使用Set，但又因为原地算法的限制，所以将获得新数组挨个赋值给原数组。思路和实现都不难。

```
var removeDuplicates = function(nums) {
    let tempArr = Array.from(new Set(nums))
    nums.length = tempArr.length
    for (let i = 0; i < tempArr.length; i++) {
        nums[i] = tempArr[i]
    }
    return nums.length
};
```

### 解法二，Splice删除重复元素
解这题的要点在于如何判断重复元素。这里，由之前第一题两数之和的巧解法想到一个思路，利用对象来存储判断该元素是否已出现。



```
var removeDuplicates = function(nums) {
    let temp = {}
    for (let i = 0; i < nums.length; i++) {
        if(temp[nums[i]]) {
            nums.splice(i, 1)
        } else {
            temp[nums[i]] = true
        }
    }
    return nums.length
};
```

```
var removeDuplicates = function(nums) {
    let temp = {}
    for (let i = nums.length; i > 0; i--) {
        temp[nums[i]] = true
        if (temp[nums[i - 1]]) {
            nums.splice(i - 1, 1)
        }
    }
    return nums.length
};
```


    // for (let i = 0; i < nums.length; i ++) {
    //     let temp = nums.indexOf(nums[i], i)
    //     if (temp !== -1) {
    //         nums.splice(temp, 1)
    //     }
    // }
    // return nums.length


        // let p = 0, q = 1;
    // while (q < nums.length) {
    //     if (nums[p] === nums[q]) {
    //         q++
    //     } else {
    //         nums[p + 1] = nums[q]
    //         p++;
    //         q++;
    //     }
    // }
    // return ++p

--- 
    // let len=nums.length;

    // for(let i=1;i<len;){ 
    //     //slice(i,j) 截取下标i开始，下标j（不包括）结束的子数组
    //     if(nums.slice(0,i).indexOf(nums[i])!==-1){// 重复项
    //         nums.splice(i,1);//删除下标从i开始的，长度为1的子数组
    //         len--;
    //     }
    //     else i++;

    // }
    // return len;