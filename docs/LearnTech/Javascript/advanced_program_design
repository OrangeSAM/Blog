---
title: 高级程序设计第四版
---
1. 如果不涉及浏览器，ECMA-262定义了语言的基础部分
    a. 语法
    b. 类型
    c. 语句
    d. 关键字
    e. 保留字
    f. 操作符
    g. 全局对象
    
2. 第二个<script>元素的代码必须在第一个<script>元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。

3. 页面在浏览器解析到<body>的起始标签时开始渲染。
4. 也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可。
5. 使用 var 操作符定义的变量会成为包含它的函数的局部变量。
6. 在函数内定义变量时省略 var 操作符，可以创建一个全局变量。
7. let 声明的范围是块作用域，而 var 声明的范围是函数作用域。
8. 块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let。
9. 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声
明的变量则会）。
10. const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且
尝试修改 const 声明的变量会导致运行时错误。
11. const 声明的作用域也是块。
12. typeOf 返回值为object，表示值为对象(而不是函数)或null。
13. Undefined 类型只有一个值，就是特殊值 undefined。
14. 无论是声明还是未声明， typeof 返回的都是字符串"undefined"。
15. 逻辑上讲， null 值表示一个空对象指针。
16. 任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。
17. 任何涉及NaN的操作始终返回NaN，NaN不等于包括NaN在内的任何值。
18. 有 3 个函数可以将非数值转换为数值： Number()、 parseInt()和 parseFloat()。
19. Number(null) => 0;   Number('') => 0;   Number(true) => 0
20. 如果第一个字符不是数值字符、加号或减号， parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。
21. Symbol.for()对每个字符串键都执行幂等操作。
22. symbol一节从第五小节开始跳过了。
23. ECMAScript 中的对象其实就是一组数据和功能的集合。
24.  每个Object实例都有如下属性和方法
    a. constructor，用于创建当前对象的参数
    b. hasOwnProperty，用于判断当前对象实例上是否存在给定的属性。
    c. isPrototypeOf，用于判断当前对象是否为另一个对象的原型。
    d. propertyIsEnumerable，用于判断给定的属性是否可以使用for-in语句枚举。与hasOwnProperty一样，属性名必须是字符串。
    e. toLocalString，返回对象的字符串表示
    f. toString，返回对象的字符串表示
    g. valueOf，返回对象对应的字符串、数值或布尔值表示。
25. 无论使用前缀递增还是前缀递减操作符，变量的值
都会在语句被求值之前改变。
26. 按位非~的最终效果是对数值取反并减 1。
27. 本质上，按位与&就是将两个数的每一个位对齐，
然后基于真值表中的规则，对每一位执行相应的与操作。
28. 按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0。
29. 按位或 | 操作在至少一位是 1 时返回 1，两位都是 0 时返回 0。
30. 按位异或 ^ 与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。
31. 左移操作符用两个小于号（ <<）表示，会按照指定的位数将数值的所有位向左移动。
32. 有符号右移由两个大于号（ >>）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。
33. 无符号右移用 3 个大于号表示（ >>>），会将数值的所有 32 位都向右移。
34. 逻辑非有一个叹号表示，可应用给ECMAScript中的任何值。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。
35. 任何关系操作符在涉及比较 NaN 时都返回 false。
36. Null ==undefined // true
37. NaN != NaN // true
38. NaN == NaN // false
39. ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。
40. 第三章完结
41. ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。
42. 保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。
43. 在操作对象时，实际上操作的是对该对象的引用而非实际的对象本身。
44. 只有引用值可以动态地添加后面可以使用的属性。
function setName(obj) {
    obj.name = 'sam'
    console.log(obj)
    obj = new Object()
    console.log(obj)
    obj.name = 'amy'
    console.log(obj)
}
let person = new Object()
setName(person)
console.log(person.name)
第四行中，obj获得了一个新的引用地址，跟传进来的obj无关。
45. 块级作用域由最近的一对包含花括号{}界定。换句话说， if 块、 while 块、 function 块，甚至连单独
的块也是 let 声明变量的作用域。
46. JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。
47. 垃圾回收的两种标记策略：标记清理和引用计数。
48. typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。
49. 任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个
上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结
如下。
50. 执行上下文分全局上下文、函数上下文和块级上下文。
51. 变量的执行上下文用于确定什么时候释放内存。
52. 引用值(或者对象)是某个特定引用类型的实例。
53. 构造函数就是用来创建新对象的函数。
54. Date.parse()方法接受一个表示日期的字符串参数，会尝试将这个字符串转换为表示该日期的毫秒数。
55. Date.UTC()方法也返回日期的毫秒表示。
56. 无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达
式的字面量表示。
57. 原始值包装类型：String() Number() Boolean()
58. ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”。
59. 当一个函数在没有明确（通过成为某个对象的方法，或者通过 call()/apply()）指定 this 值的情况下执行时， this 值等于
Global 对象。因此，调用一个简单返回 this 的函数是在任何执行上下文中获取 Global 对象的通用
方式。
60. New Map().set()是什么东西
61. New Set().add()又是什么东西
62. 可以用Array.from实现数组的浅复制
63. 与 Object 只能使用数值、字符串或符号作为键不同， Map 可以使用任何 JavaScript 数据类型作为
键。 
64. keys()和 values()分别返回以插入顺序生成键和值的迭代器
65. 与 Object 类型的一个主要差异是， Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执
行迭代操作。
66. WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。
67. 弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出
TypeError。值的类型没有限制。

看到194页










